#include <zmq.hpp>
#include <string>
#include <iostream>
#include <thread>
#include <vector>

void workerTask(int workerId) {
    zmq::context_t context(1);
    zmq::socket_t worker(context, ZMQ_SUB);
    worker.connect("tcp://localhost:5556");
    worker.setsockopt(ZMQ_SUBSCRIBE, "", 0);

    while (true) {
        zmq::message_t request;
        worker.recv(&request);

        std::string requestStr(static_cast<char*>(request.data()), request.size());
        std::cout << "Worker " << workerId << " Received Request: " << requestStr << std::endl;

        // Simulate some processing time
        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Process the request and prepare the response
        std::string responseMsg = "Response to: " + requestStr;

        zmq::message_t response(responseMsg.size());
        memcpy(response.data(), responseMsg.data(), responseMsg.size());

        // Send the response back to the server
        zmq::socket_t client(context, ZMQ_PUB);
        client.connect("tcp://localhost:5557");
        client.send(response);
    }
}

int main() {
    zmq::context_t context(1);

    // Create a PUB socket for forwarding responses to clients
    zmq::socket_t forwarder(context, ZMQ_PUB);
    forwarder.bind("tcp://*:5557");

    // Create SUB sockets for worker threads
    zmq::socket_t workers(context, ZMQ_XSUB);
    workers.bind("tcp://*:5556");

    // Wait for subscriptions from workers
    std::this_thread::sleep_for(std::chrono::seconds(1));

    // Create worker threads
    const int numWorkers = 3;
    std::vector<std::thread> workerThreads;
    for (int i = 0; i < numWorkers; ++i) {
        workerThreads.emplace_back(workerTask, i);
    }

    while (true) {
        // Pass messages between SUB and PUB sockets
        zmq::message_t message;
        workers.recv(&message);
        forwarder.send(message);
    }

    for (int i = 0; i < numWorkers; ++i) {
        workerThreads[i].join();
    }

    return 0;
}
