#include <zmq.hpp>
#include <string>
#include <iostream>
#include <thread>
#include <chrono>

void worker_thread(zmq::socket_t& worker) {
    while (true) {
        zmq::message_t identity;
        zmq::message_t request;

        worker.recv(identity, zmq::recv_flags::none);  // Receive client identity
        worker.recv(request, zmq::recv_flags::none);   // Receive request

        std::string request_str(static_cast<char*>(request.data()), request.size());
        std::cout << "Received Request from " << request_str << std::endl;

        // Simulate some processing time
        std::this_thread::sleep_for(std::chrono::seconds(1));

        // Process the request and prepare the response
        std::string response_msg = "Response to: " + request_str;

        // Send the response back to the client
        worker.send(identity, zmq::send_flags::sndmore);  // Send client identity
        worker.send("", zmq::send_flags::sndmore);         // Send empty delimiter
        worker.send(response_msg, zmq::send_flags::none); // Send response
    }
}

int main() {
    zmq::context_t context(1);
    zmq::socket_t router(context, ZMQ_ROUTER);
    router.bind("tcp://*:5555");

    // Start worker threads to handle requests
    std::vector<std::thread> worker_threads;
    for (int i = 0; i < 4; ++i) {
        zmq::socket_t worker(context, ZMQ_DEALER);
        router.connect("inproc://workers"); // Connect workers to the router
        worker_threads.emplace_back(worker_thread, std::ref(worker));
    }

    // Main thread acts as the router
    while (true) {
        zmq::message_t identity;
        zmq::message_t delimiter;
        zmq::message_t request;

        router.recv(identity, zmq::recv_flags::none);  // Receive client identity
        router.recv(delimiter, zmq::recv_flags::none); // Receive delimiter
        router.recv(request, zmq::recv_flags::none);   // Receive request

        std::string request_str(static_cast<char*>(request.data()), request.size());
        std::cout << "Received Request from " << request_str << std::endl;

        // Forward the request to a worker (round-robin)
        router.send(identity, zmq::send_flags::sndmore);  // Send client identity
        router.send("", zmq::send_flags::sndmore);         // Send empty delimiter
        router.send(request, zmq::send_flags::none);      // Send request
    }

    // Join worker threads (not reached in this example)
    for (auto& thread : worker_threads) {
        thread.join();
    }

    return 0;
}



--- client 


#include <zmq.hpp>
#include <string>
#include <iostream>

int main() {
    zmq::context_t context(1);
    zmq::socket_t requester(context, ZMQ_REQ);

    // Set a unique identity for the client (optional)
    std::string client_identity = "Client1";
    requester.setsockopt(ZMQ_IDENTITY, client_identity.c_str(), client_identity.size());

    requester.connect("tcp://localhost:5555");

    for (int request_number = 0; request_number < 5; ++request_number) {
        std::string request_msg = "Request " + std::to_string(request_number);

        // Send the request to the server
        requester.send(request_msg, zmq::send_flags::sndmore);  // Send request
        requester.send("", zmq::send_flags::none);              // Send empty delimiter

        // Receive the response from the server
        zmq::message_t response;
        requester.recv(response);

        std::string response_msg(static_cast<char*>(response.data()), response.size());
        std::cout << "Received Reply: " << response_msg << std::endl;
    }

    return 0;
}
